From 3042c33503807cd53a656eb01611887ee756e547 Mon Sep 17 00:00:00 2001
From: Reto Schneider <reto.schneider@husqvarnagroup.com>
Date: Mon, 23 Jul 2018 10:54:44 +0000
Subject: [PATCH] Add support for GD5F1GQ4UB NAND

Please note: The original OpenWrt driver (most likely) was/is written
for the GD5F4GQ4xC (e.g. GD5F4GQ4xCxIG_Rev1.8-1.pdf)

Just in case you need to understand why certain parts of the code are
the way they are.

Inspiration for /spi/spi-mt7621.c got drawn from here:
 https://github.com/narioinc/mt76xx-spi-half-duplex-patch/
---
 drivers/mtd/spi-nand/spi-nand-base.c   |  27 -----
 drivers/mtd/spi-nand/spi-nand-device.c |  80 ++++----------
 drivers/spi/spi-mt7621.c               | 196 +++++++++++++++++++++------------
 3 files changed, 152 insertions(+), 151 deletions(-)

diff --git a/drivers/mtd/spi-nand/spi-nand-base.c b/drivers/mtd/spi-nand/spi-nand-base.c
index 892589c9bc61..ffba5fa721fa 100644
--- a/drivers/mtd/spi-nand/spi-nand-base.c
+++ b/drivers/mtd/spi-nand/spi-nand-base.c
@@ -83,21 +83,6 @@ static int spi_nand_disable_ecc(struct spi_nand *snand)
 	return 0;
 }
 
-static int spi_nand_enable_quad(struct spi_nand *snand)
-{
-	int ret;
-
-	ret = snand->read_reg(snand, SPI_NAND_FEATURE_REG, snand->buf);
-	if (ret)
-		return ret;
-
-	snand->buf[0] |= SPI_NAND_QUAD_EN;
-	ret = snand->write_reg(snand, SPI_NAND_FEATURE_REG, snand->buf);
-	if (ret)
-		return ret;
-
-	return 0;
-}
 /*
  * Wait until the status register busy bit is cleared.
  * Returns a negatie errno on error or time out, and a non-negative status
@@ -205,12 +190,6 @@ static int spi_nand_write(struct spi_nand *snand)
 {
 	int ret;
 
-	/* Enable quad mode */
-	ret = spi_nand_enable_quad(snand);
-	if (ret) {
-		dev_err(snand->dev, "error %d enabling quad mode\n", ret);
-		return ret;
-	}
 	/* Store the page to cache */
 	ret = snand->store_cache(snand, 0, snand->buf_size, snand->data_buf);
 	if (ret < 0) {
@@ -285,12 +264,6 @@ static int spi_nand_read_page(struct spi_nand *snand, unsigned int page_addr,
 		}
 	}
 
-	/* Enable quad mode */
-	ret = spi_nand_enable_quad(snand);
-	if (ret) {
-		dev_err(snand->dev, "error %d enabling quad mode\n", ret);
-		return ret;
-	}
 	/* Get page from the device cache into our internal buffer */
 	ret = snand->read_cache(snand, page_offset, length, snand->data_buf);
 	if (ret < 0) {
diff --git a/drivers/mtd/spi-nand/spi-nand-device.c b/drivers/mtd/spi-nand/spi-nand-device.c
index 95db20b050fc..d46c70440b8e 100644
--- a/drivers/mtd/spi-nand/spi-nand-device.c
+++ b/drivers/mtd/spi-nand/spi-nand-device.c
@@ -44,61 +44,23 @@
 
 #define SPI_NAND_GD5F_READID_LEN	2
 
-#define SPI_NAND_GD5F_ECC_MASK		(BIT(0) | BIT(1) | BIT(2))
-#define SPI_NAND_GD5F_ECC_UNCORR	(BIT(0) | BIT(1) | BIT(2))
+#define SPI_NAND_GD5F_ECC_MASK		(BIT(0) | BIT(1))
+#define SPI_NAND_GD5F_ECC_UNCORR	BIT(1)
 #define SPI_NAND_GD5F_ECC_SHIFT		4
 
-static int spi_nand_gd5f_ooblayout_256_ecc(struct mtd_info *mtd, int section,
-					struct mtd_oob_region *oobregion)
-{
-	if (section)
-		return -ERANGE;
-
-	oobregion->offset = 128;
-	oobregion->length = 128;
-
-	return 0;
-}
-
-static int spi_nand_gd5f_ooblayout_256_free(struct mtd_info *mtd, int section,
-					struct mtd_oob_region *oobregion)
-{
-	if (section)
-		return -ERANGE;
-
-	oobregion->offset = 1;
-	oobregion->length = 127;
-
-	return 0;
-}
-
-static const struct mtd_ooblayout_ops spi_nand_gd5f_oob_256_ops = {
-	.ecc = spi_nand_gd5f_ooblayout_256_ecc,
-	.free = spi_nand_gd5f_ooblayout_256_free,
-};
+#define SPI_NAND_GD5F1GQ4U	0xd1
 
 static struct nand_flash_dev spi_nand_flash_ids[] = {
 	{
-		.name = "SPI NAND 512MiB 3,3V",
-		.id = { NAND_MFR_GIGADEVICE, 0xb4 },
-		.chipsize = 512,
-		.pagesize = SZ_4K,
-		.erasesize = SZ_256K,
-		.id_len = 2,
-		.oobsize = 256,
-		.ecc.strength_ds = 8,
-		.ecc.step_ds = 512,
-	},
-	{
-		.name = "SPI NAND 512MiB 1,8V",
-		.id = { NAND_MFR_GIGADEVICE, 0xa4 },
-		.chipsize = 512,
-		.pagesize = SZ_4K,
-		.erasesize = SZ_256K,
+		.name = "SPI NAND GD5F1GQ4UB 128Mbyte 3,3V",
+		.id = { NAND_MFR_GIGADEVICE, SPI_NAND_GD5F1GQ4U },
+		.chipsize = 128,
+		.pagesize = SZ_2K,
+		.erasesize = SZ_128K,
 		.id_len = 2,
-		.oobsize = 256,
+		.oobsize = 128,
 		.ecc.strength_ds = 8,
-		.ecc.step_ds = 512,
+		.ecc.step_ds = 2048,
 	},
 };
 
@@ -330,10 +292,9 @@ static int spi_nand_device_read_cache(struct spi_nand *snand,
 	cmd->cmd[0] = (spi->mode & SPI_RX_QUAD) ? SPI_NAND_READ_CACHE_X4 :
 			((spi->mode & SPI_RX_DUAL) ? SPI_NAND_READ_CACHE_X2 :
 			SPI_NAND_READ_CACHE);
-	cmd->cmd[1] = 0; /* dummy byte */
-	cmd->cmd[2] = (u8)((page_offset & 0xff00) >> 8);
-	cmd->cmd[3] = (u8)(page_offset & 0xff);
-	cmd->cmd[4] = 0; /* dummy byte */
+	cmd->cmd[1] = (u8)((page_offset & 0xff00) >> 8);
+	cmd->cmd[2] = (u8)(page_offset & 0xff);
+	cmd->cmd[3] = 0; /* dummy byte */
 	cmd->n_rx = length;
 	cmd->rx_buf = read_buf;
 	cmd->rx_nbits = (spi->mode & SPI_RX_QUAD) ? 4 :
@@ -368,8 +329,9 @@ static int spi_nand_gd5f_read_id(struct spi_nand *snand, u8 *buf)
 	struct spi_nand_device_cmd *cmd = &snand_dev->cmd;
 
 	memset(cmd, 0, sizeof(struct spi_nand_device_cmd));
-	cmd->n_cmd = 1;
+	cmd->n_cmd = 2;
 	cmd->cmd[0] = SPI_NAND_READ_ID;
+	cmd->cmd[1] = 0; /* Address 0 returns both manufacturer and device IDs - GD5FxGQ4xBxIG */
 	cmd->n_rx = SPI_NAND_GD5F_READID_LEN;
 	cmd->rx_buf = buf;
 
@@ -386,8 +348,14 @@ static void spi_nand_gd5f_ecc_status(unsigned int status,
 					     SPI_NAND_GD5F_ECC_MASK;
 
 	*ecc_error = (ecc_status == SPI_NAND_GD5F_ECC_UNCORR) ? 1 : 0;
-	if (*ecc_error == 0)
-		*corrected = (ecc_status > 1) ? (2 + ecc_status) : 0;
+	if (*ecc_error == 0) {
+		if (!ecc_status)
+			*corrected = 0;
+		else if(ecc_status == 1)
+			*corrected = 7; /* Worst case assumption as ECCSE1/ECCSE0 is missing here */
+		else /* ecc_status == 0b10 */
+			*corrected = 8;
+	}
 }
 
 static int spi_nand_device_probe(struct spi_device *spi)
@@ -424,7 +392,7 @@ static int spi_nand_device_probe(struct spi_device *spi)
 	case SPI_NAND_GD5F:
 		snand->read_id = spi_nand_gd5f_read_id;
 		snand->get_ecc_status = spi_nand_gd5f_ecc_status;
-		snand->ooblayout = &spi_nand_gd5f_oob_256_ops;
+		snand->ooblayout = &nand_ooblayout_lp_ops;
 		break;
 	default:
 		dev_err(snand->dev, "unknown device\n");
diff --git a/drivers/spi/spi-mt7621.c b/drivers/spi/spi-mt7621.c
index 0f479079dbcf..f5cacc4e6be9 100644
--- a/drivers/spi/spi-mt7621.c
+++ b/drivers/spi/spi-mt7621.c
@@ -90,12 +90,7 @@ static void mt7621_spi_reset(struct mt7621_spi *rs, int duplex)
 
 	master |= 7 << 29;
 	master |= 1 << 2;
-#ifdef CONFIG_SOC_MT7620
-	if (duplex)
-		master |= 1 << 10;
-	else
-#endif
-		master &= ~(1 << 10);
+	master &= ~(1 << 10);
 
 	mt7621_spi_write(rs, MT7621_SPI_MASTER, master);
 }
@@ -106,7 +101,8 @@ static void mt7621_spi_set_cs(struct spi_device *spi, int enable)
 	int cs = spi->chip_select;
 	u32 polar = 0;
 
-        mt7621_spi_reset(rs, cs);
+	mt7621_spi_reset(rs, cs);
+
 	if (enable)
 		polar = BIT(cs);
 	mt7621_spi_write(rs, MT7621_SPI_POLAR, polar);
@@ -177,7 +173,7 @@ static inline int mt7621_spi_wait_till_ready(struct spi_device *spi)
 }
 
 static int mt7621_spi_transfer_half_duplex(struct spi_master *master,
-					   struct spi_message *m)
+						struct spi_message *m)
 {
 	struct mt7621_spi *rs = spi_master_get_devdata(master);
 	struct spi_device *spi = m->spi;
@@ -269,103 +265,167 @@ static int mt7621_spi_transfer_half_duplex(struct spi_master *master,
 	return 0;
 }
 
-#ifdef CONFIG_SOC_MT7620
-static int mt7621_spi_transfer_full_duplex(struct spi_master *master,
-					   struct spi_message *m)
+static int mt7621_spi_mb_transfer_half_duplex(struct spi_master *master,
+						struct spi_message *m)
 {
 	struct mt7621_spi *rs = spi_master_get_devdata(master);
 	struct spi_device *spi = m->spi;
 	unsigned int speed = spi->max_speed_hz;
 	struct spi_transfer *t = NULL;
 	int status = 0;
-	int i, len = 0;
-	int rx_len = 0;
+	int i = 0, len = 0;
+	u8 is_write = 0;
 	u32 data[9] = { 0 };
 	u32 val = 0;
+	u32 transfer_len = 0;
+	int cs_active = 0;
 
 	mt7621_spi_wait_till_ready(spi);
+	dev_dbg(&spi->dev, "seven spidev test ->cs:\n");
 
 	list_for_each_entry(t, &m->transfers, transfer_list) {
-		const u8 *buf = t->tx_buf;
-
-		if (t->rx_buf)
-			rx_len += t->len;
+		const u8 *txbuf = t->tx_buf;
+		u8 *rxbuf = t->rx_buf;
 
-		if (!buf)
-			continue;
-
-		if (WARN_ON(len + t->len > 16)) {
+		if (t->tx_buf == NULL && t->rx_buf == NULL && t->len) {
+			dev_err(&spi->dev,
+				 "message rejected: invalid transfer data buffers\n");
 			status = -EIO;
 			goto msg_done;
 		}
 
-		for (i = 0; i < t->len; i++, len++)
-			data[len / 4] |= buf[i] << (8 * (len & 3));
-		if (speed > t->speed_hz)
-			speed = t->speed_hz;
-	}
-
-	if (WARN_ON(rx_len > 16)) {
-		status = -EIO;
-		goto msg_done;
-	}
+		if (rxbuf)
+			is_write = 0;
+		else if(txbuf)
+			is_write = 1;
 
-	if (mt7621_spi_prepare(spi, speed)) {
-		status = -EIO;
-		goto msg_done;
-	}
-
-	for (i = 0; i < len; i += 4)
-		mt7621_spi_write(rs, MT7621_SPI_DATA0 + i, data[i / 4]);
-
-	val |= len * 8;
-	val |= (rx_len * 8) << 12;
-	mt7621_spi_write(rs, MT7621_SPI_MOREBUF, val);
-
-	mt7621_spi_set_cs(spi, 1);
-
-	val = mt7621_spi_read(rs, MT7621_SPI_TRANS);
-	val |= SPI_CTL_START;
-	mt7621_spi_write(rs, MT7621_SPI_TRANS, val);
-
-	mt7621_spi_wait_till_ready(spi);
-
-	mt7621_spi_set_cs(spi, 0);
-
-	for (i = 0; i < rx_len; i += 4)
-		data[i / 4] = mt7621_spi_read(rs, MT7621_SPI_DATA4 + i);
+		if (mt7621_spi_prepare(spi, speed)) {
+			status = -EIO;
+			goto msg_done;
+		}
 
-	m->actual_length = rx_len;
+		transfer_len = t->len/4;
+		if (!cs_active) {
+			mt7621_spi_set_cs(spi, 1);
+			cs_active = 1;
+		}
 
-	len = 0;
-	list_for_each_entry(t, &m->transfers, transfer_list) {
-		u8 *buf = t->rx_buf;
+		if(transfer_len) {   /* for word transfer */
+			u32 u32TxNum = 0;
+
+			while ( transfer_len > 0 ) {
+				u32TxNum = transfer_len % 8;
+				if ( !u32TxNum )
+					u32TxNum = 8;
+
+				for ( i=0; i<u32TxNum*4; i++) {
+					if ( is_write ) { /* for write transfer */
+						data[i / 4] |= *txbuf++ << (8 * (i & 3));
+					}
+					//else  /* for read transfer */
+				}
+#if 0
+				for(i=0; i<u32TxNum*4; i += 4)
+					printk("0x%x, ", data[i/4]);
+
+				printk("\n");
+#endif
+				data[0] = swab32(data[0]);
+				val = 0;
+				if(is_write) {
+					for(i=0; i<u32TxNum*4; i += 4)
+						mt7621_spi_write(rs, MT7621_SPI_OPCODE + i, data[i / 4]);
+
+					val = (min_t(int, u32TxNum*4, 4) * 8) << 24; /* must be set 32 */
+					val |= ((u32TxNum*4) - 4) * 8;               /* mosi_cnt */
+				} else
+					val |= ((u32TxNum*4) * 8) << 12;             /* miso_cnt */
+
+				mt7621_spi_write(rs, MT7621_SPI_MOREBUF, val);
+				val = mt7621_spi_read(rs, MT7621_SPI_TRANS);
+				val |= SPI_CTL_START;
+				mt7621_spi_write(rs, MT7621_SPI_TRANS, val);
+
+				mt7621_spi_wait_till_ready(spi);
+
+				if(!is_write) {
+					for (i = 0; i < u32TxNum*4; i += 4)
+						data[i / 4] = mt7621_spi_read(rs, MT7621_SPI_DATA0 + i);
+
+					for (i = 0; i < u32TxNum*4; i++)
+						*rxbuf++ = data[i / 4] >> (8 * (i & 3));
+				}
+
+				len += u32TxNum*4;
+				transfer_len -= u32TxNum;
+				memset(data, 0, sizeof(data));
+			}
+		}
 
-		if (!buf)
-			continue;
+		transfer_len = t->len % 4;
+		if(transfer_len) { /* for bytes transfer 0-3bytes*/
+			for ( i=0; i<transfer_len; i++ ) {
+				if(is_write)
+					data[i / 4] |= *txbuf++ << (8 * (i & 3));
+			}
+
+			data[0] = swab32(data[0]);
+			data[0] >>= (4 - transfer_len) * 8;
+
+			val = 0;
+			if(is_write) {
+				for(i=0; i<transfer_len; i += 4)
+					mt7621_spi_write(rs, MT7621_SPI_OPCODE + i, data[i / 4]);
+
+				val = (min_t(int, transfer_len, 4) * 8) << 24;  /* must be 32 */
+			} else {
+				 val |= (transfer_len* 8) << 12;         /* miso_cnt */
+			}
+			mt7621_spi_write(rs, MT7621_SPI_MOREBUF, val);
+			val = mt7621_spi_read(rs, MT7621_SPI_TRANS);
+			val |= SPI_CTL_START;
+			mt7621_spi_write(rs, MT7621_SPI_TRANS, val);
+
+			mt7621_spi_wait_till_ready(spi);
+
+			if(!is_write) {
+				for (i = 0; i < transfer_len; i += 4)
+					data[i / 4] = mt7621_spi_read(rs, MT7621_SPI_DATA0 + i);
+
+				for (i = 0; i < transfer_len; i++)
+					*rxbuf++ = data[i / 4] >> (8 * (i & 3));
+			}
+			len += transfer_len;
+			memset(data, 0, sizeof(data));
+		}
 
-		for (i = 0; i < t->len; i++, len++)
-			buf[i] = data[len / 4] >> (8 * (len & 3));
+		m->actual_length = len;     //+ rx_len;
+		if (t->cs_change) {
+			 mt7621_spi_set_cs(spi, 0);
+			 cs_active = 0;
+		}
 	}
 
 msg_done:
+	if (cs_active)
+		mt7621_spi_set_cs(spi, 0);
+
 	m->status = status;
 	spi_finalize_current_message(master);
 
 	return 0;
 }
-#endif
 
 static int mt7621_spi_transfer_one_message(struct spi_master *master,
-					   struct spi_message *m)
+						struct spi_message *m)
 {
 	struct spi_device *spi = m->spi;
-#ifdef CONFIG_SOC_MT7620
 	int cs = spi->chip_select;
 
 	if (cs)
-		return mt7621_spi_transfer_full_duplex(master, m);
-#endif
+		return mt7621_spi_mb_transfer_half_duplex(master, m);
+
+	/* Default behavior used for SPI NOR on CS0 */
 	return mt7621_spi_transfer_half_duplex(master, m);
 }
 
-- 
2.11.0

